# Set of opcodes in the instruction set for the Asap4 Processor.

# Opcode format:
# 3b condex, 2b NOP, 1b Ext, 9b Src2, 9b Src1, 9b Dest, 6b Opcode.

# Instructions with three operands:
#   inst dst src1 src2 [options]
const instructions_3operand = (
    # Unsigned arithmetic
    :ADDU,:ADDSU,:ADDCU,:ADDCSU,
    :SUBU,:SUBSU,:SUBCU,:SUBCSU,
    # Signed Arithmetic
    :ADD,:ADDS,:ADDC,:ADDCS,
    :SUB,:SUBS,:SUBC,:SUBCS,
    # Logic operations
    :OR,:AND,:XOR,
    # Conditional moves
    :MOVC,:MOVZ,:MOVCX0,:MOVCX1,
    # Shifts
    :SHL,:SHR,:SRA,:SHLC,:SHRC,:SRAC,
    # Multiplication
    :MULTL,:MULTH,:MULTLU,:MULTLH,
    # MACC
    :MACL,:MACH,:MACCL,:MACCH,
    :MACLU,:MACHU,:MACCLU,:MACCHU,
)

# Instructions with two operands:
#   inst dst src1
const instructions_2operand = (
    # Unconditional moves
    :MOVE,:MOVI,
    # Unary reductions
    :ANDWORD,:ORWORD,:XORWORD,
    # Misc logic
    :BTRV,:LSD,:LSDU,
    # Accumulate
    :ACCSH,:ACCSHU,
)

const instructions_1operand = (
    :RPT,
)

const instructions_0operand = (
    :NOP,
)

# Basic branch instructions - put them in their own category because of mask
# construction.

# TODO: add the convenience options like in the c++ simulator.
const instructions_branch = (
    :BR,:BRL
)

const instructions_stall = (
    :STALL,
)

const opcodes = union(
    instructions_3operand, 
    instructions_2operand, 
    instructions_1operand,
    instructions_0operand,
    instructions_branch,
    instructions_stall
)


#-------------------------------------------------------------------------------
# Misc. classifications of OPs

const signed_ops = (
    :ADD, :ADDS, :ADDC, :ADDCS,
    :SUB, :SUBS, :SUBC, :SUBCS,
    :LSC,
    :SRA,:SRAC,
    :MULTL, :MULTH, :MACL, :MACH, :MACCL, :MACCH, :ACCSH
)

const saturating_ops = (
    :ADDSU, :ADDCSU,
    :SUBSU, :SUBCSU,
    :ADDS, :ADDCS,
    :SUBS, :SUBCS,
)

const output_dests = (
    :output,
)

#=
The general idea here is that a macro will be created that can take
pseudo-assembly much like the C++ version of the simulator and turn it into
a vector of type AsapInstruction. Core models will then have this vector of
instructions as their program and keep a local PC to point to which instruction
they are executing on a given clock cycle.

Lables will be encoded using the standard Julia @label macro. During source code
tansformation, labels will be converted to indices of instructions in the
final vector of instructions.

- Alternatives:

This could be encoded using something like a ResumableFunction from the
ResumableFunctions package, but I feel like it would be difficult to bind the
functions to their respecitve cores in a clear and mostly type-stable manner.

Plus, using the vector of instructions format would allow an assembler to take
assembly files generated by the compiler and execute them without needing
to recompile any code.

=#

# All the symbols for expected sources in the Asap4 architecture.
const SourceSymbols = (
    :dmem,      # data memory (index needed)
    :immediate, # immediate
    :fifo,      # input fifo (index needed)
    :fifo_peek, # input fifo, no increment (index needed)
    :pointer,   # dereference hardware pointer (index needed)
    :ag,        # dereference address generator, no increment (index needed)
    :ag_pi,     # dereference address generator, increment (index needed)
    :acc,       # read lower 16 bits from accumulator
    :ret,       # read return address
)


#-------------------------------------------------------------------------------
# Destination encoding

const DestinationSymbols = (
    :dmem,      # data memory (index needed)
    :pointer,   # set hardware pointers
)

# Intermediate form for an instruction.
# The pseudo-assembly will be parsed directly into these intermediate
# instructions, which will then be analyzed to emit the final vector of
# AsapInstructions.
struct AsapIntermediate
    op   :: Symbol
    args :: Vector{Any}

    label :: Union{Symbol,Void}

    # Store the file and line numbers to provide better error messages while
    # converting the intermediate instructions into full instructions.
    file :: Symbol
    line :: Int64
end


struct InstructionOptions
    # Number of no-ops to put after this instruction.
    nops::UInt8
    # Set the "jump" flag for branches
    jump::Bool
    # conditional execution
    csx::Bool
    cxt::Bool
    cxf::Bool
    # Index of the conditional register to use.
    cx_index::UInt8
    # Options for writeback to dmem. If "true", double-write will happen
    dw::Bool
end
InstructionOptions() = InstructionOptions(
    zero(UInt8),
    false,
    false,
    false,
    false,
    zero(UInt8),
    false,
)


function getoptions(args::Vector{Any})
    # Set defaults
    nops        = zero(UInt8)
    jump        = false
    csx         = false
    cxt         = false
    cxf         = false
    cx_index    = zero(UInt8)
    dw          = false

    # Check for nops  
    for (i,nop) in enumerate((:nop1, :nop2, :nop3))
        if nop in args
            nops = UInt8(i) 
        end
    end
    # Check for jump
    if :j in args
        jump = true
    end
    # Check for conditional execution
    :csx0 in args && (csx = true; cx_index = UInt8(0))
    :csx1 in args && (csx = true; cx_index = UInt8(1))
    :cxt0 in args && (cxt = true; cx_index = UInt8(0))
    :cxt1 in args && (cxt = true; cx_index = UInt8(1))
    :cxf0 in args && (cxf = true; cx_index = UInt8(0))
    :cxf1 in args && (cxf = true; cx_index = UInt8(1))
    # Check double write
    if :dw in args
        dw = true
    end

    return InstructionOptions(
        nops,
        jump,
        csx,
        cxt,
        cxf,
        cx_index,
        dw,
    )
    
end


struct AsapInstruction
    # The opcode of the instruction
    op :: Symbol

    src1     :: Symbol
    src1_val :: Int64

    src2     :: Symbol
    src2_val :: Int64

    dest     :: Symbol
    dest_val :: Int64

    options  :: InstructionOptions

    # Metadata
    signed      :: Bool
    saturating  :: Bool
    dest_is_output :: Bool
end

function AsapInstruction(
        op, 
        src1,
        src1_val,
        src2,
        src2_val,
        dest,
        dest_val,
        options
    )
    # Set metadata flags based on op name.
    signed          = op in signed_ops
    saturating      = op in saturating_ops
    dest_is_output  = op in output_dests
    return AsapInstruction(
        op, 
        src1, 
        src1_val, 
        src2, 
        src2_val, 
        dest, 
        dest_val, 
        options,
        # metadata
        signed,
        saturating,
        dest_is_output,
    )
end

NOP() = AsapInstruction(:nop, :none, -1, :none, -1, :none, -1, InstructionOptions())


# Methods on instructions - Since some values may be stored in some 
# less-than-obvious places, use these methods to get these fields if needed.

# Get branch-target - This is encoded in the "dest_val" field of the branch
# instructions.
branch_target(i::AsapInstruction) = i.dest_val

# 
