# Set of opcodes in the instruction set for the Asap4 Processor.

# Opcode format:
# 3b condex, 2b NOP, 1b Ext, 9b Src2, 9b Src1, 9b Dest, 6b Opcode.

# Instructions with three operands:
#   inst dst src1 src2 [options]
const instructions_3operand = (
    # Unsigned arithmetic
    :ADDU,:ADDSU,:ADDCU,:ADDCSU,
    :SUBU,:SUBSU,:SUBCU,:SUBCSU,
    # Signed Arithmetic
    :ADD,:ADDS,:ADDC,:ADDCS,
    :SUB,:SUBS,:SUBC,:SUBCS,
    # Logic operations
    :OR,:AND,:XOR,
    # Conditional moves
    :MOVC,:MOVZ,:MOVCX0,:MOVCX1,
    # Shifts
    :SHL,:SHR,:SRA,:SHLC,:SHRC,:SRAC,
    # Multiplication
    :MULTL,:MULTH,:MULTLU,:MULTLH,
    # MACC
    :MACL,:MACH,:MACCL,:MACCH,
    :MACLU,:MACHU,:MACCLU,:MACCHU,
)

# Instructions with two operands:
#   inst dst src1
const instructions_2operand = (
    # Unconditional moves
    :MOVE,:MOVI,
    # Unary reductions
    :ANDWORD,:ORWORD,:XORWORD,
    # Misc logic
    :BTRV,:LSD,:LSDU,
    # Accumulate
    :ACCSH,:ACCSHU,
)

const instructions_1operand = (
    :RPT,
)

const instructions_0operand = (
    :NOP,
)

# Basic branch instructions - put them in their own category because of mask
# construction.

# TODO: add the convenience options like in the c++ simulator.
const instructions_branch = (
    :BR,:BRL
)

const instructions_stall = (
    :STALL,
)

# Special pseudo instructions that still need special treatment from the
# assembler.
const instructions_pseudo = (
    :END_RPT,
)

const opcodes = union(
    instructions_3operand, 
    instructions_2operand, 
    instructions_1operand,
    instructions_0operand,
    instructions_branch,
    instructions_stall,
    instructions_pseudo,
)


#-------------------------------------------------------------------------------
# Misc. classifications of OPs

const signed_ops = (
    :ADD, :ADDS, :ADDC, :ADDCS,
    :SUB, :SUBS, :SUBC, :SUBCS,
    :LSC,
    :SRA,:SRAC,
    :MULTL, :MULTH, :MACL, :MACH, :MACCL, :MACCH, :ACCSH
)

const saturating_ops = (
    :ADDSU, :ADDCSU,
    :SUBSU, :SUBCSU,
    :ADDS, :ADDCS,
    :SUBS, :SUBCS,
)

const output_dests = (
    :output,
)

#=
The general idea here is that a macro will be created that can take
pseudo-assembly much like the C++ version of the simulator and turn it into
a vector of type AsapInstruction. Core models will then have this vector of
instructions as their program and keep a local PC to point to which instruction
they are executing on a given clock cycle.

Lables will be encoded using the standard Julia @label macro. During source code
tansformation, labels will be converted to indices of instructions in the
final vector of instructions.

- Alternatives:

This could be encoded using something like a ResumableFunction from the
ResumableFunctions package, but I feel like it would be difficult to bind the
functions to their respecitve cores in a clear and mostly type-stable manner.

Plus, using the vector of instructions format would allow an assembler to take
assembly files generated by the compiler and execute them without needing
to recompile any code.

=#

# All the symbols for expected sources in the Asap4 architecture.
const SourceSymbols = (
    :dmem,      # data memory (index needed)
    :immediate, # immediate
    :fifo,      # input fifo (index needed)
    :fifo_peek, # input fifo, no increment (index needed)
    :pointer,   # dereference hardware pointer (index needed)
    :ag,        # dereference address generator, no increment (index needed)
    :ag_pi,     # dereference address generator, increment (index needed)
    :acc,       # read lower 16 bits from accumulator
    :ret,       # read return address
)


#-------------------------------------------------------------------------------
# Destination encoding

const DestinationSymbols = (
    :dmem,      # data memory (index needed)
    :pointer,   # set hardware pointers
)

# Intermediate form for an instruction.
# The pseudo-assembly will be parsed directly into these intermediate
# instructions, which will then be analyzed to emit the final vector of
# AsapInstructions.
mutable struct AsapIntermediate
    op   :: Symbol
    args :: Vector{Any}

    # The label assigned to this instruction
    label       :: Union{Symbol,Void}
    # The end-address if this is a repeat instruction
    repeat_start :: Union{Int64, Void}
    repeat_end  :: Union{Int64,Void}

    # Store the file and line numbers to provide better error messages while
    # converting the intermediate instructions into full instructions.
    file :: Symbol
    line :: Int64
end

# Convenience constructors.
function AsapIntermediate(
        op      ::Symbol, 
        args    ::Vector, 
        label = nothing;
        #kwargs
        repeat_start = nothing,
        repeat_end = nothing,
        file = :null,
        line = 0
    ) 

    return AsapIntermediate(op, args, label, repeat_start, repeat_end, file, line)
end

# For equality purposes, ignore file and line. Makes for easier testing.
# If "file" and "line" become important for testing function equality, I may
# have to revisit this.
Base.:(==)(a::T, b::T) where {T <: AsapIntermediate} = 
    a.op == b.op &&
    a.args == b.args &&
    a.label == b.label &&
    a.repeat_start == b.repeat_start &&
    a.repeat_end == b.repeat_end



# -- Removed in favor of storing these directly in the instruction type to
# avoid a level of wrapping.
# struct InstructionOptions
#     # Number of no-ops to put after this instruction.
#     nops::UInt8
#     # Set the "jump" flag for branches
#     jump::Bool
#     # conditional execution
#     csx::Bool
#     cxt::Bool
#     cxf::Bool
#     # Index of the conditional register to use.
#     cx_index::UInt8
#     # Options for writeback to dmem. If "true", double-write will happen
#     dw::Bool
# end
# InstructionOptions() = InstructionOptions(
#     zero(UInt8),
#     false,
#     false,
#     false,
#     false,
#     zero(UInt8),
#     false,
# )
# 
# 
# function getoptions(args::Vector{Any})
#     # Set defaults
#     nops        = zero(UInt8)
#     jump        = false
#     csx         = false
#     cxt         = false
#     cxf         = false
#     cx_index    = zero(UInt8)
#     dw          = false
# 
#     # Check for nops  
#     for (i,nop) in enumerate((:nop1, :nop2, :nop3))
#         if nop in args
#             nops = UInt8(i) 
#         end
#     end
#     # Check for jump
#     if :j in args
#         jump = true
#     end
#     # Check for conditional execution
#     :csx0 in args && (csx = true; cx_index = UInt8(0))
#     :csx1 in args && (csx = true; cx_index = UInt8(1))
#     :cxt0 in args && (cxt = true; cx_index = UInt8(0))
#     :cxt1 in args && (cxt = true; cx_index = UInt8(1))
#     :cxf0 in args && (cxf = true; cx_index = UInt8(0))
#     :cxf1 in args && (cxf = true; cx_index = UInt8(1))
#     # Check double write
#     if :dw in args
#         dw = true
#     end
# 
#     return InstructionOptions(
#         nops,
#         jump,
#         csx,
#         cxt,
#         cxf,
#         cx_index,
#         dw,
#     )
#     
# end

function oneofin(a, b)
    for i in a
        i in b && return true
    end
    return false
end

function getoptions(args)
    # Construct an empty container for kwargs for the options.
    kwargs = Pair{Symbol,Any}[]
    # Check for nops. Iterate in the order of number of NOPS for style points.
    nops = zero(UInt8)
    for (i, nop) in enumerate((:nop1, :nop2, :nop3))
        if nop in args
            nops = UInt8(i)
        end
    end
    # Save nop argument if not zero
    if !iszero(nops)
        push!(kwargs, (:nops => nops))
    end
    # Check fo jump
    if :j in args
        push!(kwargs, (:jump => true))
    end
    # Check for conditional execution
    # Initialize conditional execution to "false"
    csx = oneofin((:csx0, :csx1, :cxt0, :cxt1, :cfx0, :cfx1), args)
    if csx
        push!(kwargs, (:csx => true))
        # Figure out the index of the conditional execution flag.
        if oneofin((:csx0, :cxt0, :cxf0), args)
            cx_index = UInt8(0)
        else
            cx_index = UInt8(1)
        end
        push!(kwargs, (:cx_index => cx_index))
    end
    # Check double write
    if :dw in args
        push!(kwargs, (:sw => false))
    end

    return kwargs
end


@with_kw struct AsapInstruction
    # The opcode of the instruction. Set the defaultes for the "with_kw" 
    # constructor to be a "nop" if constructed with no arguments.
    op :: Symbol = :nop

    # Sources and destination will come in pairs
    # 1. A Symbol, indication the name of the source or destination. Use symbols
    #    instead of Strings or Integers because Symbols are interred in Julia 
    #    and thus compare for equality faster than strings, and are clearer
    #    visually than integers.
    # 
    # 2. An extra metadata value as an integer. For some sources/destinations,
    #    such as dmem references, this integer will serve as an index, allowing
    #    for fast decoding.
    #
    #    For other instructions, like immediates or branches, this index will
    #    store other information like branch address, immediate value, or
    #    start and end addresses for RPT loops. Convenient setter and accessor
    #    functions will be provided so this doesn't have to be esplicitly 
    #    remembered
    src1       :: Symbol = :null
    src1_index :: Int64  = -1

    src2       :: Symbol = :null
    src2_index :: Int64  = -1

    dest       :: Symbol = :null
    dest_index :: Int64  = -1

    # ------------------------ #
    # Options for instructions #
    # ------------------------ #

    # Number of no-ops to put after this instruction.
    nops :: UInt8 = zero(UInt8)
    # Set the "jump" flag for branches
    jump :: Bool = false
    # conditional execution
    # TODO: Make this an enum for smaller storage?
    csx :: Bool = false
    cxt :: Bool = false
    cxf :: Bool = false
    # Index of the conditional register to use.
    cx_index::UInt8 = zero(UInt8)
    # Options for writeback to dmem. If "true", single-write will happen
    # Default to this as it should be the common case and to bring it into
    # alignment with the c++ simulator
    sw::Bool = true

    # Metadata for faster decoding during Stage 4 arithmetic or for performing
    # stall detection
    signed      :: Bool = false
    saturating  :: Bool = false
    dest_is_output :: Bool = false
end

# Removed in favor of using the @with_kw macro and explicitly passed kwargs.
# function AsapInstruction(
#         op, 
#         src1,
#         src1_val,
#         src2,
#         src2_val,
#         dest,
#         dest_val,
#         options
#     )
#     # Set metadata flags based on op name.
#     signed          = op in signed_ops
#     saturating      = op in saturating_ops
#     dest_is_output  = op in output_dests
#     return AsapInstruction(
#         op, 
#         src1, 
#         src1_val, 
#         src2, 
#         src2_val, 
#         dest, 
#         dest_val, 
#         options,
#         # metadata
#         signed,
#         saturating,
#         dest_is_output,
#     )
# end

# Alias "NOP" to an empty constructor, which should provide a NOP by default.
NOP() = AsapInstruction()


# Methods on instructions - Since some values may be stored in some 
# less-than-obvious places, use these methods to get these fields if needed.

# Get branch-target - This is encoded in the "dest_val" field of the branch
# instructions.
function branch_target(i::AsapInstruction) 
    # For debugging, ensure that this is only called on branch instructions.
    # If not, something ahs gone wrong.
    @assert i.op == :BR || i.op == :BRL
    return i.dest_index
end

# For repeat start, use src2_index. src1_index may be used if the RPT instruction
# uses a dmem or other source
function repeat_start(i::AsapInstruction)
    @assert i.op == :RPT
    return i.src2_index
end

# Similarlym, use the dest_index for the repeat end.
function repeat_end(i::AsapInstruction)
    @assert i.op == :RPT
    return i.dest_index
end

set_branch_target(x) = (:dest_index => x)
set_repeat_start(x) = (:src2_index => x)
set_repeat_end(x) = (:dest_index => x)
